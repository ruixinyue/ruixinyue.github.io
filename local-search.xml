<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hive编程指南——笔记（一）</title>
    <link href="/2020/06/23/Hive%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%E2%80%94%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/06/23/Hive%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%E2%80%94%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="3-数据类型和文件格式"><a href="#3-数据类型和文件格式" class="headerlink" title="3. 数据类型和文件格式"></a>3. 数据类型和文件格式</h2><h3 id="3-1-基本数据类型"><a href="#3-1-基本数据类型" class="headerlink" title="3.1 基本数据类型"></a>3.1 基本数据类型</h3><table><thead><tr><th>Hive数据类型</th><th>Java数据类型</th><th>长度</th><th>例子</th></tr></thead><tbody><tr><td>TINYINT</td><td>byte</td><td>1byte有符号整数</td><td>20</td></tr><tr><td>SMALINT</td><td>short</td><td>2byte有符号整数</td><td>20</td></tr><tr><td>INT</td><td>int</td><td>4byte有符号整数</td><td>20</td></tr><tr><td>BIGINT</td><td>long</td><td>8byte有符号整数</td><td>20</td></tr><tr><td>BOOLEAN</td><td>boolean</td><td>布尔类型，true或者false</td><td>TRUE FALSE</td></tr><tr><td>FLOAT</td><td>float</td><td>单精度浮点数</td><td>3.14159</td></tr><tr><td>DOUBLE</td><td>double</td><td>双精度浮点数</td><td>3.14159</td></tr><tr><td>STRING</td><td>string</td><td>字符系列。可以指定字符集。可以使用单引号或者双引号。</td><td>‘now is the time’ “for all good men”</td></tr><tr><td>TIMESTAMP</td><td></td><td>时间类型</td><td></td></tr><tr><td>BINARY</td><td></td><td>字节数组</td><td></td></tr></tbody></table><ul><li>hive中的所有数据类型是对java中接口的实现，具体细节和java中的数据类型一样</li><li>对于Hive的String类型相当于数据库的varchar类型，该类型是一个可变的字符串，不过它不能声明其中最多能存储多少个字符，理论上它可以存储2GB的字符数。</li></ul><h2 id="3-2-集合数据类型"><a href="#3-2-集合数据类型" class="headerlink" title="3.2 集合数据类型"></a>3.2 集合数据类型</h2><p>表6-2</p><table><thead><tr><th>数据类型</th><th>描述</th><th>语法示例</th></tr></thead><tbody><tr><td>STRUCT</td><td>和c语言中的struct类似，都可以通过“点”符号访问元素内容。例如，如果某个列的数据类型是STRUCT{first STRING, last STRING},那么第1个元素可以通过字段.first来引用。</td><td>struct(‘John’，’Doe’)</td></tr><tr><td>MAP</td><td>MAP是一组键-值对元组集合，使用数组表示法可以访问数据。例如，如果某个列的数据类型是MAP，其中键-&gt;值对是’first’-&gt;’John’和’last’-&gt;’Doe’，那么可以通过字段名[‘last’]获取最后一个元素</td><td>map(‘first’，’JOIN’，’last’，’Doe’)</td></tr><tr><td>ARRAY</td><td>数组是一组具有相同类型和名称的变量的集合。这些变量称为数组的元素，每个数组元素都有一个编号，编号从零开始。例如，数组值为[‘John’,  ‘Doe’]，那么第2个元素可以通过数组名[1]进行引用。</td><td>Array(‘John’，’Doe’)</td></tr></tbody></table><ul><li>Hive有三种复杂数据类型ARRAY、MAP 和 STRUCT。ARRAY和MAP与Java中的Array和Map类似，而STRUCT与C语言中的Struct类似，它封装了一个命名字段集合，复杂数据类型允许任意层次的嵌套。</li><li>例子</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">test</span>(<span class="hljs-keyword">name</span> <span class="hljs-keyword">string</span>,friends <span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">string</span>&gt;,children <span class="hljs-keyword">map</span>&lt;<span class="hljs-keyword">string</span>, <span class="hljs-built_in">int</span>&gt;,address <span class="hljs-keyword">struct</span>&lt;street:<span class="hljs-keyword">string</span>, city:<span class="hljs-keyword">string</span>&gt;)<span class="hljs-keyword">row</span> <span class="hljs-keyword">format</span> <span class="hljs-keyword">delimited</span> <span class="hljs-keyword">fields</span> <span class="hljs-keyword">terminated</span> <span class="hljs-keyword">by</span> <span class="hljs-string">','</span>collection items <span class="hljs-keyword">terminated</span> <span class="hljs-keyword">by</span> <span class="hljs-string">'_'</span><span class="hljs-keyword">map</span> <span class="hljs-keyword">keys</span> <span class="hljs-keyword">terminated</span> <span class="hljs-keyword">by</span> <span class="hljs-string">':'</span><span class="hljs-keyword">lines</span> <span class="hljs-keyword">terminated</span> <span class="hljs-keyword">by</span> <span class="hljs-string">'\n'</span>;</code></pre><p>row format delimited fields terminated by ‘,’ – 列分隔符</p><p>collection items terminated by ‘_’     –MAP STRUCT 和 ARRAY 的分隔符(数据分割符号)</p><p>map keys terminated by ‘:’                – MAP中的key与value的分隔符</p><p>lines terminated by ‘\n’;                  – 行分隔符</p><p>存储的数据：</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"songsong"</span>,    <span class="hljs-attr">"friends"</span>: [<span class="hljs-string">"bingbing"</span> , <span class="hljs-string">"lili"</span>] ,       <span class="hljs-comment">//列表Array, </span>    <span class="hljs-attr">"children"</span>: &#123;                      <span class="hljs-comment">//键值Map,</span>        <span class="hljs-attr">"xiao song"</span>: <span class="hljs-number">18</span> ,        <span class="hljs-attr">"xiaoxiao song"</span>: <span class="hljs-number">19</span>    &#125;    <span class="hljs-string">"address"</span>: &#123;                      <span class="hljs-comment">//结构Struct,</span>        <span class="hljs-attr">"street"</span>: <span class="hljs-string">"hui long guan"</span> ,        <span class="hljs-attr">"city"</span>: <span class="hljs-string">"beijing"</span>     &#125;&#125;</code></pre><h3 id="3-3-文本文件数据编码"><a href="#3-3-文本文件数据编码" class="headerlink" title="3.3 文本文件数据编码"></a>3.3 文本文件数据编码</h3><table><thead><tr><th>分隔符</th><th>描述</th></tr></thead><tbody><tr><td>\n</td><td>对于文本文件来说，每行都是一条记录，因此换行符可以分割记录</td></tr><tr><td>^A（Ctrl+A）</td><td>用于分隔字段（列）。在CREATE TABLE语句中可以使用八进制编码\001表示</td></tr><tr><td>^B</td><td>用于分隔ARRARY或者STRUCT中的元素，或用于MAP中键-值对之间的分隔。在CREATE TABLE 语句中可以使用八进制编码\002表示</td></tr><tr><td>^C</td><td>用于MAP中键和值之间的分隔。在CREATE TABLE 语句中可以使用八进制编码\003表示</td></tr></tbody></table><pre><code class="hljs cos">CREATE TABLE employees (　name　　　　　　　STRING,　salary　　　　　　FLOAT,　subordinates 　　ARRAY&lt;STRING&gt;,　deductions　　　　MAP&lt;STRING, FLOAT&gt;,　address　　　　　STRUCT&lt;street:STRING, city:STRING, state:STRING, zip:INT&gt;)<span class="hljs-comment">;</span>&#123;　<span class="hljs-string">"name"</span>: <span class="hljs-string">"John Doe"</span>,　<span class="hljs-string">"salary"</span>: <span class="hljs-number">100000.0</span>,　<span class="hljs-string">"subordinates"</span>: [<span class="hljs-string">"Mary Smith"</span>, <span class="hljs-string">"Todd Jones"</span>],　<span class="hljs-string">"deductions"</span>: &#123;　　<span class="hljs-string">"Federal Taxes"</span>: 　.<span class="hljs-number">2</span>,　　<span class="hljs-string">"State Taxes"</span>: 　　.<span class="hljs-number">05</span>,　　<span class="hljs-string">"Insurance"</span>: 　　　.<span class="hljs-number">1</span>　&#125;,　<span class="hljs-string">"address"</span>: &#123;　　<span class="hljs-string">"street"</span>: <span class="hljs-string">"1 Michigan Ave."</span>,　　<span class="hljs-string">"city"</span>: <span class="hljs-string">"Chicago"</span>,　　<span class="hljs-string">"state"</span>: <span class="hljs-string">"IL"</span>,　　<span class="hljs-string">"zip"</span>: <span class="hljs-number">60600</span>　&#125;&#125;John Doe<span class="hljs-symbol">^A100000</span><span class="hljs-number">.0</span><span class="hljs-symbol">^AMary</span> Smith<span class="hljs-symbol">^BTodd</span> Jones<span class="hljs-symbol">^AFederal</span> Taxes<span class="hljs-symbol">^C</span><span class="hljs-number">.2</span><span class="hljs-symbol">^BStateTaxes</span><span class="hljs-symbol">^C</span><span class="hljs-number">.05</span>^ BInsurance<span class="hljs-symbol">^C</span><span class="hljs-number">.1</span><span class="hljs-symbol">^A1</span> Michigan Ave.<span class="hljs-symbol">^BChicago</span><span class="hljs-symbol">^BIL</span><span class="hljs-symbol">^B60600</span>Mary Smith<span class="hljs-symbol">^A80000</span><span class="hljs-number">.0</span><span class="hljs-symbol">^ABill</span> King<span class="hljs-symbol">^AFederal</span> Taxes<span class="hljs-symbol">^C</span><span class="hljs-number">.2</span><span class="hljs-symbol">^BState</span> Taxes<span class="hljs-symbol">^C</span><span class="hljs-number">.05</span><span class="hljs-symbol">^BInsurance</span>^ C<span class="hljs-number">.1</span><span class="hljs-symbol">^A100</span> Ontario St.<span class="hljs-symbol">^BChicago</span><span class="hljs-symbol">^BIL</span><span class="hljs-symbol">^B60601</span>Todd Jones<span class="hljs-symbol">^A70000</span><span class="hljs-number">.0</span><span class="hljs-symbol">^AFederal</span> Taxes<span class="hljs-symbol">^C</span><span class="hljs-number">.15</span><span class="hljs-symbol">^BState</span> Taxes<span class="hljs-symbol">^C</span><span class="hljs-number">.03</span><span class="hljs-symbol">^BInsurance</span><span class="hljs-symbol">^C</span><span class="hljs-number">.1</span><span class="hljs-symbol">^A200</span>   Chicago Ave.<span class="hljs-symbol">^BOak</span> Park<span class="hljs-symbol">^BIL</span><span class="hljs-symbol">^B60700</span>Bill King<span class="hljs-symbol">^A60000</span><span class="hljs-number">.0</span><span class="hljs-symbol">^AFederal</span> Taxes<span class="hljs-symbol">^C</span><span class="hljs-number">.15</span><span class="hljs-symbol">^BState</span>Taxes<span class="hljs-symbol">^C</span><span class="hljs-number">.03</span><span class="hljs-symbol">^BInsurance</span><span class="hljs-symbol">^C</span><span class="hljs-number">.1</span><span class="hljs-symbol">^A300</span> Obscure Dr.<span class="hljs-symbol">^BObscuria</span><span class="hljs-symbol">^BIL</span><span class="hljs-symbol">^B60100</span></code></pre><h3 id="3-4-读时模式"><a href="#3-4-读时模式" class="headerlink" title="3.4 读时模式"></a>3.4 读时模式</h3><p>不懂</p><h2 id="4-HiveQL：数据定义"><a href="#4-HiveQL：数据定义" class="headerlink" title="4. HiveQL：数据定义"></a>4. HiveQL：数据定义</h2><h3 id="4-1-Hive中的数据库"><a href="#4-1-Hive中的数据库" class="headerlink" title="4.1 Hive中的数据库"></a>4.1 Hive中的数据库</h3><ol><li>数据库类似命名空间或者目录</li><li>创建 create database [if not exists] database_name LOCATION … COMMENT…  WITH DBPROPERTIES()<ol><li>location 指定位置</li><li>comment 添加注释</li><li>WITH DBPROPERTIES 添加属性</li></ol></li><li>查看数据库 show database [like …]</li><li>查看数据的详细信息 describe database_name</li><li>使用数据库use database_name</li><li>查看当前正在使用的数据库 SELECT current_database()</li><li>删除数据库 drop database if exists database_name [CASCADE]</li></ol><h3 id="4-2-修改数据库"><a href="#4-2-修改数据库" class="headerlink" title="4.2 修改数据库"></a>4.2 修改数据库</h3><ol><li>修改数据库，只能修改DBPROPERTIES，数据库名字和存储位置都不能修改，alter database  database_name SET DBPROPERTIES (‘edited-by’ = ‘Joe Dba’);</li><li>没有办法可以删除或者“重置”数据库属性</li></ol><h3 id="4-3-创建表"><a href="#4-3-创建表" class="headerlink" title="4.3 创建表"></a>4.3 创建表</h3><ol><li>创建表create table if not exists table_name()</li><li>if not exists 只判断有没有同名的表存在，不去比较属性是不是不一样，如果是想修改表的属性，需要先删除原来的表，再重建新表</li><li>Hive会自动增加两个表属性：一个是last_modified_by，其保存着最后修改这个表的用户的用户名；另一个是last_modified_time，其保存着最后一次修改<br>的新纪元时间秒。</li><li>查看表结构 desc table_name，只输出包含有列描述信息的表结构信息</li><li>查看详细的表结构信息，DESCRIBE EXTENDED table_name，展示结构很乱</li><li>查看详细的表结构信息，DESCRIBE formatted table_name，展示结构很清晰</li><li>SHOW TBLPROPERTIES table_name命令，用于列举出某个表的TBLPROPERTIES属性<br>信息。</li><li>拷贝一个已存在的表结构，不包含数据，CREATE TABLE IF NOT EXISTS mydb.employees2<br>LIKE mydb.employees;</li><li>查看所有的表：show tables [like …]；支持简单正则</li><li>指定查看摸个数据库下的表：show tables in database_name;</li></ol><h4 id="4-3-1-管理表"><a href="#4-3-1-管理表" class="headerlink" title="4.3.1 管理表"></a>4.3.1 管理表</h4><ol><li>hive控制着数据的生命周期，删除表的时候，表中的数据也会被删除</li></ol><h4 id="4-3-2-外部表"><a href="#4-3-2-外部表" class="headerlink" title="4.3.2 外部表"></a>4.3.2 外部表</h4><ol><li>CREATE EXTERNAL TABLE IF NOT EXISTS table_name() ROW FORMAT DELIMITED FIELDS TERMINATED BY ‘,’  LOCATION ‘/data/stocks’;</li><li>hive删除外部表时候，表中的数据不会被删除</li><li>查看是外部表还是内部表：DESCRIBE EXTENDED table_name中tableType:</li></ol><h3 id="4-4-分区表、管理表"><a href="#4-4-分区表、管理表" class="headerlink" title="4.4 分区表、管理表"></a>4.4 分区表、管理表</h3><ol><li>分区表，更快的查询</li><li>存储，按照分区字段分目录存储</li><li>分区字段使用起来和普通字段是一样的</li><li>如果表中的数据太多，select代价很大，可以开启hive 的严格模式，select必须要加上where条件，set hive.mapred.mode=strict; set hive.mapred.mode=nonstrict;</li></ol><blockquote><p>如果表中的数据以及分区个数都非常大的话，执行这样一个包含有所有<br>分区的查询可能会触发一个巨大的MapReduce任务。一个高度建议的安全措施就是<br>将Hive设置为“strict(严格)”模式，这样如果对分区表进行查询而WHERE子句没<br>有加分区过滤的话，将会禁止提交这个任务。用户也可以按照下面的语句将属性值<br>设置为“nostrict(非严格)”</p></blockquote><ol start="5"><li>查看分区show partitions table_name partition(’‘);</li></ol><h4 id="4-4-1-外部分区表"><a href="#4-4-1-外部分区表" class="headerlink" title="4.4.1 外部分区表"></a>4.4.1 外部分区表</h4><ol><li>创建分区，ALTER TABLE … ADD PARTITION</li><li>往分区内移入数据，hdfs拷贝数据到对应的目录下</li><li>查看到分区数据所在的路径： DESCRIBE EXTENDED log_messages PARTITION (year=2012, month=1, day=2);</li></ol><h4 id="4-4-2-自定义表的存储格式"><a href="#4-4-2-自定义表的存储格式" class="headerlink" title="4.4.2 自定义表的存储格式"></a>4.4.2 自定义表的存储格式</h4><ol><li>hive默认存储格式：text</li><li>创建表的时候指定：STORED AS TEXTFILE;</li><li>记录的解析是由序列化器/反序列化器（或者缩写为SerDe）来控制的。</li><li>ROW FORMAT SERDE …指定SerDe</li><li>STORED AS INPUTFORMAT … OUTPUTFORMAT …子句分别指定了用于输入格式和输出格式的Java类。</li><li><strong>Hive使用一个inputformat对象将输入流分割成记录，然后使用一个outputformat对象来将记录格式化为输出流（例如查询的输出结果），再使用一个SerDe在读数据时将记录解析成列，在写数据时将列编码成记录。</strong>—有疑问</li></ol><h3 id="4-5-删除表"><a href="#4-5-删除表" class="headerlink" title="4.5 删除表"></a>4.5 删除表</h3><ol><li>drop table if exists table_name</li><li>如果开启回收站功能，会将删除的数据移到用户根目录下的.Trash目录下，即hdfs中的/user/$USER/.Trash目录</li></ol><h3 id="4-6-修改表"><a href="#4-6-修改表" class="headerlink" title="4.6 修改表"></a>4.6 修改表</h3><p>不怎么常用，一般会选择重新建表</p><h4 id="4-6-2-增加，修改，删除分区"><a href="#4-6-2-增加，修改，删除分区" class="headerlink" title="4.6.2 增加，修改，删除分区"></a>4.6.2 增加，修改，删除分区</h4><ol><li>增加分区：ALTER TABLE log_messages ADD IF NOT EXISTS PARTITION (year = 2011, month = 1, day = 1) LOCATION ‘/logs/2011/01/01’</li><li>修改分区路径：ALTER TABLE log_messages PARTITION(year = 2011, month = 12, day = 2) SET LOCATION ‘s3n://ourbucket/logs/2011/01/02’;</li><li>删除分区：ALTER TABLE log_messages DROP IF EXISTS PARTITION(year = 2011, month = 12, day = 2);</li></ol>]]></content>
    
    
    <categories>
      
      <category>Hive</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hive</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL中字符串相关的部分函数（一）</title>
    <link href="/2020/06/23/Mysql%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%9A%84%E9%83%A8%E5%88%86%E5%87%BD%E6%95%B0/"/>
    <url>/2020/06/23/Mysql%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%9A%84%E9%83%A8%E5%88%86%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-trim"><a href="#1-trim" class="headerlink" title="1. trim"></a>1. trim</h2><p><strong>TRIM([{BOTH | LEADING | TRAILING} [remstr] FROM] str)</strong> </p><p>作用：去掉指定的字符</p><ol><li><p>不指定指定字符，默认去掉空格</p><ul><li><p>默认去掉左右空格： select trim(‘  a   ‘);   –’a’</p></li><li><p>去掉左边空格：select ltrim(‘   a  ‘);  –’a  ‘</p></li><li><p>去掉右边空格：select rtrim(‘  a  ‘);  –’  a’</p></li></ul></li><li><p>指定字符</p><ul><li>去掉两边字符：select trim(both ‘|’  from ‘|abc|’); –’abc’</li><li>去掉左边字符：select trim(LEADING ‘|’  from ‘|abc|’); –’abc|’</li><li>去掉右边字符：select trim(TRAILING ‘|’  from ‘|abc|’); –’|abc’</li></ul></li></ol><h2 id="2-instr"><a href="#2-instr" class="headerlink" title="2. instr"></a>2. instr</h2><p><strong>instr(str,substr)</strong> </p><p>作用：返回substr第一次在str中出现的位置</p><p>select instr(‘aaa_0001’ ,  ‘_’); –4</p><h2 id="3-substr"><a href="#3-substr" class="headerlink" title="3. substr"></a>3. substr</h2><p><strong>substr(str,pos[,len])</strong></p><p>作用：从字符串中的指定位置pos开始取一个字符串返回</p><p>select substr(‘aaa_0001’ ,  4); –’_0001’</p><h2 id="4-substring"><a href="#4-substring" class="headerlink" title="4. substring"></a>4. substring</h2><p><strong>substring(str,n,len)</strong></p><p>作用：获取子串，从n开始截取str中长度为len的子串</p><p>select substring(‘aaa_0001’, 1, 3); –’aaa’</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hive常用函数</title>
    <link href="/2020/06/18/hive%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <url>/2020/06/18/hive%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-concat：拼接字符串"><a href="#1-concat：拼接字符串" class="headerlink" title="1. concat：拼接字符串"></a>1. concat：拼接字符串</h2><p> <strong>concat(string|binary A, string|binary B…)</strong></p><p> <strong>作用</strong>：将字符串按顺序拼接成一个字符串</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">concat</span>(<span class="hljs-string">'a'</span>,<span class="hljs-string">'_'</span>,<span class="hljs-string">'b'</span>);  <span class="hljs-comment">-- a_b</span></code></pre><p> <strong>注意</strong>：如果有任何一个参数为null，返回结果为null </p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">concat</span>(<span class="hljs-string">'a'</span>,<span class="hljs-string">'_'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-literal">null</span>);  <span class="hljs-comment">-- NULL</span></code></pre><h2 id="2-concat-ws：指定拼接字符串拼接"><a href="#2-concat-ws：指定拼接字符串拼接" class="headerlink" title="2. concat_ws：指定拼接字符串拼接"></a>2. concat_ws：指定拼接字符串拼接</h2><p><strong>concat_ws(string SEP, string A, string B…)</strong></p><p>concat_ws是concat的特殊形式，可以自定义分隔符SEP</p><p>select concat_ws(‘_’,’a’,’b’);    – a_b</p><p><strong>注意</strong>：</p><ol><li>分隔符可以任何参数，字符串，特殊符号都可以</li><li>分隔符为null时，结果为null</li><li>concat_ws会忽略其他除分隔符外其他为null的参数，不会忽略空字符串</li></ol><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">concat_ws</span>(<span class="hljs-string">'W'</span>,<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>);<span class="hljs-comment">-- aWb</span><span class="hljs-keyword">select</span> <span class="hljs-keyword">concat_ws</span>(<span class="hljs-literal">null</span>,<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>);<span class="hljs-comment">-- NULL</span><span class="hljs-keyword">select</span> <span class="hljs-keyword">concat_ws</span>(<span class="hljs-string">'#'</span>,<span class="hljs-string">'a'</span>,<span class="hljs-string">' '</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">''</span>,<span class="hljs-string">'c'</span>);<span class="hljs-comment">-- a# #b##c</span><span class="hljs-keyword">select</span> <span class="hljs-keyword">concat_ws</span>(<span class="hljs-string">'|'</span>,<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-literal">null</span>,<span class="hljs-string">'c'</span>,<span class="hljs-literal">null</span>,<span class="hljs-string">'d'</span>);<span class="hljs-comment">-- a|b|c|d</span></code></pre><h2 id="3-nvl：空值处理"><a href="#3-nvl：空值处理" class="headerlink" title="3. nvl：空值处理"></a>3. nvl：空值处理</h2><p><strong>nvl(T value, T default_value)</strong></p><p>如果value为null，返回default_value,否则返回value，开发中十分常用</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> nvl(<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>);<span class="hljs-comment">-- a</span><span class="hljs-keyword">select</span> nvl(<span class="hljs-literal">null</span>, <span class="hljs-string">'b'</span>);<span class="hljs-comment">-- b</span></code></pre><p><strong>补充</strong>：去除为null和空’’的值，select nvl(id,’’) != ‘’;</p><h2 id="4-datediff：计算两个日期的差值"><a href="#4-datediff：计算两个日期的差值" class="headerlink" title="4.  datediff：计算两个日期的差值"></a>4.  datediff：计算两个日期的差值</h2><p><strong>datediff(string enddate, string startdate)</strong></p><p>返回值类型：int</p><p>日期比较函数，返回结束日期减去开始日期的天数</p><pre><code class="hljs sql">hive&gt; select datediff('2020-02-02','2020-02-01');  --返回1</code></pre><p>注：传入时间的格式必须是YYYY-MM-DD形式</p><pre><code class="hljs sql">hive&gt; select datediff('20200202','20200201');  --返回null</code></pre><h2 id="5-cast：显式转换"><a href="#5-cast：显式转换" class="headerlink" title="5. cast：显式转换"></a>5. cast：显式转换</h2><p><strong>类型转换：</strong></p><ol><li>任何类型都可以自动转成一种范围更大的类型，TINYINT,SMALLINT,INT,BIGINT,FLOAT和STRING都可以隐式地转换成DOUBLE；</li><li>BOOLEAN类型不能转换为其他任何数据类型。</li><li>从小范围往大范围转，不能自动完成，需要加cast关键字做强制类型转换。</li><li>转换失败返回null。</li></ol><p><strong>常用：</strong></p><p>1.获取当前日期：</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">cast</span> (<span class="hljs-keyword">current_date</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">string</span>)； <span class="hljs-comment">-- 2020-06-12</span></code></pre><p>2.string转数字类型，参与运算</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  <span class="hljs-keyword">max</span>(<span class="hljs-keyword">cast</span>(code <span class="hljs-keyword">as</span> <span class="hljs-built_in">int</span>)); <span class="hljs-comment">-- code 是string类型的一串数字 例：110911893303 ，2000098777，</span><span class="hljs-comment">--为取到code的最大值，如果不强转成int，按string比较，会取到的最大值是2000098777</span></code></pre><h2 id="6-case-when-then-else-end"><a href="#6-case-when-then-else-end" class="headerlink" title="6. case when then else end"></a>6. case when then else end</h2><p><b>CASE WHEN a THEN b [WHEN c THEN d]* [ELSE e] END<b/></p><p>解释：When a = true, returns b; when c = true, returns d; else returns e.</p><p>类似java中的switch case语句和scala中的模式匹配</p><p><strong>示例：</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> age <span class="hljs-keyword">from</span> student;</code></pre><p><img src="https://img-blog.csdnimg.cn/20200612142231143.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">case</span> <span class="hljs-keyword">when</span> age &lt; <span class="hljs-number">18</span> <span class="hljs-keyword">then</span> <span class="hljs-string">"少年"</span> <span class="hljs-keyword">when</span> age &lt; <span class="hljs-number">60</span> <span class="hljs-keyword">then</span> <span class="hljs-string">"成年人"</span>  <span class="hljs-keyword">else</span> <span class="hljs-string">"老年人"</span> <span class="hljs-keyword">end</span> <span class="hljs-keyword">from</span> student;</code></pre><p><img src="https://img-blog.csdnimg.cn/20200612142313352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3gxMjM0NV8=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="7-sum-case-when"><a href="#7-sum-case-when" class="headerlink" title="7. sum case when"></a>7. sum case when</h2><p><strong>对是否满足条件进行计数</strong></p><p>统计各个年龄段人的数量：</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">sum</span>(<span class="hljs-keyword">case</span> <span class="hljs-keyword">when</span> age&lt; <span class="hljs-number">18</span> <span class="hljs-keyword">then</span> <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span> <span class="hljs-keyword">end</span>) <span class="hljs-keyword">as</span> teenager, <span class="hljs-keyword">sum</span>(<span class="hljs-keyword">case</span> <span class="hljs-keyword">when</span> age&lt; <span class="hljs-number">60</span> <span class="hljs-keyword">and</span> age&gt;=<span class="hljs-number">18</span> <span class="hljs-keyword">then</span> <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span> <span class="hljs-keyword">end</span>) <span class="hljs-keyword">as</span> adult, <span class="hljs-keyword">sum</span>(<span class="hljs-keyword">case</span> <span class="hljs-keyword">when</span> age&gt;= <span class="hljs-number">60</span> <span class="hljs-keyword">then</span> <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span> <span class="hljs-keyword">end</span>) <span class="hljs-keyword">as</span> elderly <span class="hljs-keyword">from</span> student;</code></pre><p><img src="https://img-blog.csdnimg.cn/20200612142451709.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="8-row-number-over"><a href="#8-row-number-over" class="headerlink" title="8. row_number() over()"></a>8. row_number() over()</h2><p><strong>row_number() over()可以给每个行数据根据分组排序形成一个序号</strong></p><p>示例：</p><p>取最近的一条订单号</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test_row_number_over;</code></pre><p><img src="https://img-blog.csdnimg.cn/20200612142740868.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">no</span>,paydate,rn <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-keyword">no</span>,paydate,row_number() <span class="hljs-keyword">over</span>(<span class="hljs-keyword">distribute</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">no</span> <span class="hljs-keyword">sort</span> <span class="hljs-keyword">by</span> paydate <span class="hljs-keyword">desc</span> ) <span class="hljs-keyword">as</span> rn <span class="hljs-keyword">from</span> test_row_number_over) t ;</code></pre><p><img src="https://img-blog.csdnimg.cn/20200612142826546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3gxMjM0NV8=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">no</span>,paydate <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-keyword">no</span>,paydate,row_number() <span class="hljs-keyword">over</span>(<span class="hljs-keyword">distribute</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">no</span> <span class="hljs-keyword">sort</span> <span class="hljs-keyword">by</span> paydate <span class="hljs-keyword">desc</span> ) <span class="hljs-keyword">as</span> rn <span class="hljs-keyword">from</span> test_row_number_over) t <span class="hljs-keyword">where</span> t.rn=<span class="hljs-number">1</span>;</code></pre><p><img src="https://img-blog.csdnimg.cn/20200612142933642.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="9-greatest：多列中取到最大值"><a href="#9-greatest：多列中取到最大值" class="headerlink" title="9. greatest：多列中取到最大值"></a>9. greatest：多列中取到最大值</h2><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test_greatest;</code></pre><p><img src="https://img-blog.csdnimg.cn/20200612143100732.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">greatest</span>(a,b,c) <span class="hljs-keyword">from</span> test_greatest; <span class="hljs-comment">-- 3 7</span></code></pre><p><strong>注：</strong> 如果含有string类型的列，返回null</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">greatest</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-string">"a"</span>); <span class="hljs-comment">--null</span></code></pre><h2 id="10-collect-list：列转行"><a href="#10-collect-list：列转行" class="headerlink" title="10.  collect_list：列转行"></a>10.  collect_list：列转行</h2><p>Hive中collect相关的函数有collect_list和collect_set。</p><p>它们都是将分组中的某列转为一个数组返回，不同的是collect_list不去重而collect_set去重。</p><p>示例：</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test_collect_list;</code></pre><p><img src="https://img-blog.csdnimg.cn/20200612143327465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3gxMjM0NV8=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><strong>1. collect_list 不去重</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">name</span>,collect_list(video) <span class="hljs-keyword">from</span> test_collect_list <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">name</span>;</code></pre><p><img src="https://img-blog.csdnimg.cn/20200612143348422.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><strong>2. collect_set 去重</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">name</span>,collect_set(video) <span class="hljs-keyword">from</span> test_collect_list <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">name</span>;</code></pre><p><img src="https://img-blog.csdnimg.cn/202006121434126.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><strong>3. concat_ws修改拼接格式</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">name</span>,<span class="hljs-keyword">concat_ws</span>(<span class="hljs-string">','</span>,collect_list(video)) <span class="hljs-keyword">from</span> test_collect_list <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">name</span>;</code></pre><p><img src="https://img-blog.csdnimg.cn/20200612143438521.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>Hive</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hive</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Impala入门</title>
    <link href="/2020/06/16/impala%E5%85%A5%E9%97%A8/"/>
    <url>/2020/06/16/impala%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Impala简介"><a href="#1-Impala简介" class="headerlink" title="1. Impala简介"></a>1. Impala简介</h2><h3 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h3><ol><li>Impala提供对存储在HDFS、Hbase或Amazon Simple Storage Service（S3）数据的高性能、低延迟的交互式SQL查询功能。</li><li>基于Hive，使用Hive的元数据，类似Hive的SQL，JDBC和用户操作界面。Impala和Hive的定位不同，Impala查询速度快，可以做为大数据查询的补充，Hive更适合做需要长时间运行的跑批操作。</li><li>Impala由Cloudera公司推出，2017年11份从Apache Incubator毕业，是CDH平台首选的PB级大数据实时查询分析引擎。</li></ol><h3 id="1-2-优缺点"><a href="#1-2-优缺点" class="headerlink" title="1.2 优缺点"></a>1.2 优缺点</h3><h4 id="1-2-1-优点"><a href="#1-2-1-优点" class="headerlink" title="1.2.1 优点"></a>1.2.1 优点</h4><ol><li>使用SQL查询，使用上手快。</li><li>兼容Hive，可以访问hive的metastore，对hive数据直接做数据分析。</li><li>基于内存运算，不需要把中间结果写入磁盘，省掉了大量的I/O开销。</li><li>无需转换为Mapreduce，直接访问存储在HDFS，HBase中的数据进行作业调度，速度快。</li><li>使用了支持Data locality的I/O调度机制，尽可能地将数据和计算分配在同一台机器上进行，减少了网络开销。</li><li>支持各种文件格式，如TEXTFILE 、SEQUENCEFILE 、RCFile、Parquet。</li></ol><h4 id="1-2-2-缺点"><a href="#1-2-2-缺点" class="headerlink" title="1.2.2 缺点"></a>1.2.2 缺点</h4><ol><li>对内存的依赖大，且完全依赖于hive。</li><li>实践中，分区超过1万，性能严重下降。</li><li>只能读取文本文件，而不能直接读取自定义二进制文件。</li><li>每当新的记录/文件被添加到HDFS中的数据目录时，该表需要被刷新。</li></ol><h3 id="1-3-Impala架构"><a href="#1-3-Impala架构" class="headerlink" title="1.3 Impala架构"></a>1.3 Impala架构</h3><p>Impala自身包含三个模块：Impalad、Statestore和Catalog，除此之外它还依赖Hive Metastore和HDFS。</p><h4 id="1-3-1-核心组件"><a href="#1-3-1-核心组件" class="headerlink" title="1.3.1 核心组件"></a>1.3.1 核心组件</h4><ol><li><p>Impalad：</p><ul><li>接收client的请求、Query执行并返回给中心协调节点</li><li>子节点上的守护进程，负责向statestore保持通信，汇报工作。</li><li>具体细节：<ul><li>query planner：翻译sql，生成计划</li><li>query coordinator：协调器，分配任务给query executor</li><li>query executor：执行查询任务</li></ul></li></ul></li><li><p>Catalog：</p><ul><li><p>分发表的元数据信息到各个impalad中；</p></li><li><p>接收来自statestore的所有请求。</p></li></ul></li><li><p>Statestore：</p><ul><li><p>负责收集分布在集群中各个impalad进程的资源信息、各节点健康状况，同步节点信息；</p></li><li><p>负责query的协调调度。</p></li></ul></li></ol><h4 id="1-3-2-执行流程"><a href="#1-3-2-执行流程" class="headerlink" title="1.3.2 执行流程"></a>1.3.2 执行流程</h4><p><img src="C:%5CUsers%5C16336%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200616172905838.png" srcset="/img/loading.gif" alt="image-20200616172905838"></p><ol><li>由Client发送一个执行SQL到任意一台Impalad的Query Planner</li><li>由Query Planner 把SQL发向Query Coordinator</li><li>由Query Coordinator 来调度分配任务到Impalad的所有节点</li><li>各个Impalad节点的Query Executor 进行执行SQL工作</li><li>执行SQL结束以后，将结果返回给Query Coordinator</li><li>再由Query Coordinator 将结果返回给Client</li></ol><h2 id="2-操作命令"><a href="#2-操作命令" class="headerlink" title="2. 操作命令"></a>2. 操作命令</h2><h3 id="2-1-外部shell命令"><a href="#2-1-外部shell命令" class="headerlink" title="2.1 外部shell命令"></a>2.1 外部shell命令</h3><table><thead><tr><th align="left">选项</th><th>描述</th></tr></thead><tbody><tr><td align="left">-h,  –help</td><td>显示帮助信息</td></tr><tr><td align="left">-v  or –version</td><td>显示版本信息</td></tr><tr><td align="left">-i  hostname, –impalad=hostname</td><td>指定连接运行  impalad 守护进程的主机。默认端口是 21000。</td></tr><tr><td align="left">-q query, –query=query</td><td>从命令行中传递一个shell  命令。执行完这一语句后 shell 会立即退出。</td></tr><tr><td align="left">-f query_file, –query_file= query_file</td><td>传递一个文件中的 SQL  查询。文件内容必须以分号分隔</td></tr><tr><td align="left">-o filename or –output_file filename</td><td>保存所有查询结果到指定的文件。通常用于保存在命令行使用 -q 选项执行单个查询时的查询结果。</td></tr><tr><td align="left">-c</td><td>查询执行失败时继续执行</td></tr><tr><td align="left">-d default_db or  –database=default_db</td><td>指定启动后使用的数据库，与建立连接后使用use语句选择数据库作用相同，如果没有指定，那么使用default数据库</td></tr><tr><td align="left">-r or –refresh_after_connect</td><td>建立连接后刷新  Impala 元数据</td></tr><tr><td align="left">-p, –show_profiles</td><td>对 shell 中执行的每一个查询，显示其查询执行计划</td></tr><tr><td align="left">-B（–delimited）</td><td>去格式化输出</td></tr><tr><td align="left">–output_delimiter=character</td><td>指定分隔符</td></tr><tr><td align="left">–print_header</td><td>打印列名</td></tr></tbody></table><h3 id="2-2-内部shell命令"><a href="#2-2-内部shell命令" class="headerlink" title="2.2 内部shell命令"></a>2.2 内部shell命令</h3><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>help</td><td>显示帮助信息</td></tr><tr><td>explain  <sql></td><td>显示执行计划</td></tr><tr><td>profile</td><td>(查询完成后执行） 查询最近一次查询的底层信息</td></tr><tr><td>shell <shell></td><td>不退出impala-shell执行shell命令</td></tr><tr><td>version</td><td>显示版本信息（同于impala-shell  -v）</td></tr><tr><td>connect</td><td>连接impalad主机，默认端口21000（同于impala-shell -i）</td></tr><tr><td>refresh <tablename></td><td>增量刷新元数据库</td></tr><tr><td>invalidate metadata</td><td>全量刷新元数据库（慎用）（同于 impala-shell -r）</td></tr><tr><td>history</td><td>历史命令</td></tr></tbody></table><h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3. 数据类型"></a>3. 数据类型</h2><table><thead><tr><th>Hive数据类型</th><th>Impala数据类型</th><th>长度</th></tr></thead><tbody><tr><td>TINYINT</td><td>TINYINT</td><td>1byte有符号整数</td></tr><tr><td>SMALINT</td><td>SMALINT</td><td>2byte有符号整数</td></tr><tr><td>INT</td><td>INT</td><td>4byte有符号整数</td></tr><tr><td>BIGINT</td><td>BIGINT</td><td>8byte有符号整数</td></tr><tr><td>BOOLEAN</td><td>BOOLEAN</td><td>布尔类型，true或者false</td></tr><tr><td>FLOAT</td><td>FLOAT</td><td>单精度浮点数</td></tr><tr><td>DOUBLE</td><td>DOUBLE</td><td>双精度浮点数</td></tr><tr><td>STRING</td><td>STRING</td><td>字符系列。可以指定字符集。可以使用单引号或者双引号。</td></tr><tr><td>TIMESTAMP</td><td>TIMESTAMP</td><td>时间类型</td></tr><tr><td>BINARY</td><td>不支持</td><td>字节数组</td></tr></tbody></table><p>注意：Impala虽然支持array，map，struct复杂数据类型，但是支持并不完全，一般处理方法，将复杂类型转化为基本类型，通过hive创建表。</p><h2 id="4-DDL操作"><a href="#4-DDL操作" class="headerlink" title="4. DDL操作"></a>4. DDL操作</h2><h2 id="5-DML操作"><a href="#5-DML操作" class="headerlink" title="5. DML操作"></a>5. DML操作</h2>]]></content>
    
    
    <categories>
      
      <category>Impala</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Impala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hive Create Table</title>
    <link href="/2020/06/12/Hive_CreateDropTruncate_Table/"/>
    <url>/2020/06/12/Hive_CreateDropTruncate_Table/</url>
    
    <content type="html"><![CDATA[<h3 id="Create-Table"><a href="#Create-Table" class="headerlink" title="Create Table"></a>Create Table</h3><pre><code class="hljs mysql">CREATE [TEMPORARY] [EXTERNAL] TABLE [IF NOT EXISTS] [db_name.]table_name    -- (Note: TEMPORARY available in Hive 0.14.0 and later)  [(col_name data_type [column_constraint_specification] [COMMENT col_comment], ... [constraint_specification])]  [COMMENT table_comment]  [PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)]  [CLUSTERED BY (col_name, col_name, ...) [SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS]  [SKEWED BY (col_name, col_name, ...)                  -- (Note: Available in Hive 0.10.0 and later)]     ON ((col_value, col_value, ...), (col_value, col_value, ...), ...)     [STORED AS DIRECTORIES]  [   [ROW FORMAT row_format]    [STORED AS file_format]     | STORED BY &#39;storage.handler.class.name&#39; [WITH SERDEPROPERTIES (...)]  -- (Note: Available in Hive 0.6.0 and later)  ]  [LOCATION hdfs_path]  [TBLPROPERTIES (property_name&#x3D;property_value, ...)]   -- (Note: Available in Hive 0.6.0 and later)  [AS select_statement];   -- (Note: Available in Hive 0.5.0 and later; not supported for external tables)</code></pre><ol><li><p>CREATE TABLE 创建一个指定名字的表，如果一个同名的表或者视图已经存在，则会抛出异常，加上IF NOT EXISTS时，如果表已经存在，Hive就会忽略掉后面的执行语句，而且不会有任何提示。</p><ul><li><p>IF NOT EXISTS只比较表名，不比较表的模式。</p><blockquote><p>如果用户使用了IF NOT EXISTS，当用户所指定的表的模式和已经存在的这个表的模式不同的话，Hive不会为此做出提示。如果用户的意图是使这个表具有重新指定的那个新的模式的话，那么就需要先删除这个表，也就是丢弃之前的数据，然后再重建这张表。用户可以考虑使用一个或多个ALTER TABLE语句来修改已经存在的表的结构。</p></blockquote></li></ul></li><li><p>表名和列名不区分大小写，但SerDe和属性名区分大小写。</p><ol><li>在Hive 0.12和更早版本中，表和列名称中仅允许使用字母数字和下划线。在Hive 0.13之后，列名可以使用任何Unicode字符，但是点(.)和冒号(:)在查询时候会报错，所以在Hive 1.2.0中不允许使用它们</li><li>反引号（``）中指定的任何列名均按字面意义处理。在反引号字符串中，使用双反引号（```）表示反引号字符。反引号还可以将保留关键字用于表和列标识符。</li><li>如果要限制列名只能为字母数字和下划线字符，可以将将配置属性设置<code>hive.support.quoted.identifiers</code>为<code>none</code>。在此配置中，带反引号的名称被解释为正则表达式。</li></ol></li><li><p>不加EXTERNAL创建的表是管理表，hive管理自己的数据，要确认一个表是管理表还是外部表，请在DESCRIBE EXTENDED table_name的输出中查找tableType 。</p></li><li><p>TBLPROPERTIES可以用键值对形式，给表添加额外的一些说明。</p><p>常见用法：</p><ul><li><p>指定压缩格式：TBLPROPERTIES（“ orc.compress” =“ ZLIB”）或（“ orc.compress” =“ SNAPPY”）或（“ orc.compress” =“ NONE”</p><blockquote><p>Hive会自动增加两个表属性：一个是last_modified_by，其保存着最后修改这个表的用户的用户名；另一个是last_modified_time，其保存着最后一次修改的新纪元时间秒。</p></blockquote></li><li><p>查看TBLPROPERTIES属性：show TBLPROPERTIES table_name；</p></li></ul></li><li><p>查看表的详细信息</p><ul><li>desc  [extended|formatted]  table_name;</li><li>formatted打印的表信息比extended的更加详细，而且阅读性更强。</li></ul></li><li><p>查看某一列的详细信息</p><ul><li>desc  [extended|formatted]  table_name.column_name;</li></ul></li></ol><h2 id="Managed-and-External-Tables"><a href="#Managed-and-External-Tables" class="headerlink" title="Managed and External Tables"></a>Managed and External Tables</h2><p>hive的表从本质上分两种类型：</p><ul><li>管理表</li><li>外部表</li></ul><h3 id="管理表"><a href="#管理表" class="headerlink" title="管理表"></a>管理表</h3><ol><li>默认创建的表，或者是Managed修饰的表是管理表，元数据，文件，统计信息等由Hive自己管理，即Hive控制着数据的生命周期，当我们删除一个管理表时候，表中的数据也会被删除。</li><li>管理表的数据存储在属性<code>hive.metastore.warehouse.dir</code>指定的路径下，默认情况下存储在类似/user/hive/warehouse/databasename.db/tablename/的路径下。在创建表的时候，如果指定location的位置，就可以覆盖默认位置。</li></ol><h3 id="外部表"><a href="#外部表" class="headerlink" title="外部表"></a>外部表</h3><ol><li>外部表描述外部文件的元数据信息，外部表的文件可以由Hive之外的工具管理，外部表可以访问存储在例如Azure存储卷（ASV）或远程HDFS位置的源中的数据。如果更改了外部表的结构或分区，则可以使用MSCK REPAIR TABLE table_name语句刷新元数据信息。</li><li>删除外部表不会删除表中的数据，只会删除掉描述表的元数据信息。</li></ol><h3 id="区别与应用"><a href="#区别与应用" class="headerlink" title="区别与应用"></a>区别与应用</h3><ol><li>管理表拥有对表中数据的管理权，而外部表没有，删除管理表，元数据信息和表中的数据都会被删除，删除外部表只删除元数据信息，表中的数据不会被删除。</li><li>需要Hive需要管理表的生命周期或生成临时表时候，使用管理表，管理表不适合和其他工具共享数据。</li><li>当表中的文件已经存在时候，使用外部表，即使表被删除，文件也会保留。</li></ol><h3 id="管理表和外部表转换"><a href="#管理表和外部表转换" class="headerlink" title="管理表和外部表转换"></a>管理表和外部表转换</h3><ol><li><p>内部表转外部表</p><p>alter table table_name set tblproperties(‘EXTERNAL’=’TRUE’);</p></li><li><p>外部表转内部表</p><p>alter table table_name set tblproperties(‘EXTERNAL’=’FALSE’);</p></li><li><p>查看是外部表还是管理表</p><pre><code class="hljs gams">hive&gt; desc formatted table_name;<span class="hljs-keyword">Table</span> Type:       MANAGED_TABLE    //管理表<span class="hljs-keyword">Table</span> Type:       EXTERNAL_TABLE   //外部表</code></pre></li></ol><p><strong>注：</strong>(‘EXTERNAL’=’TRUE’)和(‘EXTERNAL’=’FALSE’)为固定写法，区分大小写</p>]]></content>
    
    
    <categories>
      
      <category>Hive</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hive</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/06/12/hello-world/"/>
    <url>/2020/06/12/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
